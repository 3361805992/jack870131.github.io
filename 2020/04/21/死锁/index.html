<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/me.jpg">
	<link rel="shortcut icon" href="/img/me.jpg">
	
			    <title>
    Jack's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="java, computer science, programming">
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">JACK</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            	<a href="#s1">Category</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithms/">Algorithms</a></li><li><a class="category-link" href="/categories/IoTDB/">IoTDB</a></li><li><a class="category-link" href="/categories/LeetCode/">LeetCode</a></li><li><a class="category-link" href="/categories/Operating-System/">Operating System</a></li><li><a class="category-link" href="/categories/Other/">Other</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="Tag">
		                Tag
		            </a>
		        </li>
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
					<li class="translate-style">
						<a id="translateButtonObject" href="javascript:translatePage();">繁&#8644;简</a>
					</li>
                    
                    <li>
                        <a title="github" href="https://github.com/jack870131" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="linkedin" href="https://www.linkedin.com/in/tsung-han-jack-tsai-62696314b" target="_blank" rel="noopener">
                            <i class="icon fa fa-linkedin"></i>
                        </a>
                    </li>
                    
			</ul>
			<script type="text/javascript" src="/js/tw_cn.js"></script>
			<script type="text/javascript">
				var defaultEncoding = 2; //網站編寫字體是否繁體，1-繁體，2-簡體
				var translateDelay = 0; //延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0
				var cookieDomain = "https://jack870131.github.io/"; //Cookie地址, 一定要設定, 通常為你的網址
				var translateButtonId = "translateLink"; //默認互換id
				translateInitilization();
			</script>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://i.imgur.com/YFDq3rc.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>死锁</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><blockquote>
<p><strong>定义</strong>: 当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。</p>
</blockquote>
<p>一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为<strong>进程死锁</strong>。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>在进程对设备、文件等取得排他性访问权时，有可能会出现<strong>死锁</strong>。这类需要排它性使用的对象称为<strong>资源 (resource)</strong>。资源分为以下两类:</p>
<ul>
<li><p><strong>可抢占资源</strong>: 可以拥有其他进程抢占而不会产生副作用 (如: 存储器)。</p>
</li>
<li><p><strong>不可抢占资源</strong>: 不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来 (与死锁有关)。</p>
</li>
</ul>
<p>死锁与不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解。</p>
<h3 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h3><p>死锁发生时，以下四个条件必须满足:</p>
<ol>
<li><strong>互斥条件</strong>: 每个资源要么已经分配给一个进程，要么就是可用的。</li>
<li><strong>占有和等待条件</strong>: 已经得到了某个资源的进程可以再请求新的资源。</li>
<li><strong>不可抢占条件</strong>: 已经分配给一个进程的资源不能被强制性地抢占，它只能被占有它的进程显示地释放</li>
<li><strong>环路等待条件</strong>: 死锁发生时，系统中一定有由两个或两个以上的进程组成的环路，该环路中的每个进程都在等待着下一个进程所占有的资源</li>
</ol>
<h2 id="处里死锁的策略"><a href="#处里死锁的策略" class="headerlink" title="处里死锁的策略"></a>处里死锁的策略</h2><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>检测死锁分为策略可分为两种:</p>
<ul>
<li><strong>每种类型一个资源的死锁检测</strong>: 可以使用一个简单的算法，依次将每一个节点作为一棵树的根结点，并进行深度优先搜索。如果碰到已经遇到过的节点，那么就算是找到了一个环。如果从任何给定的节点出发的弧都被穷举了，那么就回溯到前面的节点。如果回溯到根并且不能再深入下去，那么从当前节点出发的子图就不包含任贺环。如果所有的节点都是如此，那么整个图就不存在环，也就是说系统不存在死锁。</li>
<li><strong>每种类型多个资源 (多种相同的资源) 的死锁检测</strong>: 算法的第1步是寻找可以运行完毕的进程，该进程的特点是它有资源请求并且可被当前的可用资源满足。这一选中的进程随后就被运行完毕，再这段时间内它释放自己持有的所有资源并将它们返回到可用资源库中。然后这一资源被标记为完成。如果所有的进程最终都能运行完毕的话，就不存在死锁的情况。如果其中某些进程一直不能运行，那么它们就是死锁进程。</li>
</ul>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p>假设已经检测到死锁，接下来就需要一些方法来使系统重回正轨。可以使用以下方法来对死锁情况进行恢复:</p>
<ol>
<li><strong>利用抢占恢复</strong>: 再不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着又送回，这种做法的可行性取决于该资源本身的特性。这种方法比较困难且不可能，若选择挂起某个进程，则在很大程度上取决于哪个进程拥有比较容易回收回的资源。</li>
<li><strong>利用回滚恢复</strong>: 周期性地对进程进行<strong>检查点检查 (checkpointed)</strong>。进程检查点检查就是将进程的状态写入一个文件以备以后重启。为了使这一过程更有效，新的检查点不应覆盖原有的文件，而应该写到新文件中。这样，当进程执行时，将会有一系列的检查点文件累积。一旦检测到死锁，就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点上开始，这样拥有所需资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他的资源。在该检查点后所做的工作都丢失。简单来说，就是将该进程复位到一个更早的状态，那时它还没有取的所需的资源，接着就把这个资源分配给一个死锁进程。</li>
<li><strong>通过杀死进程恢复</strong>: 杀死一个或若干个进程。一种方法是杀掉环中的一个进程，如果走运的话，其他进程将可以继续。如果行不通的话，就需要继续杀死别的进程直到打破死循环。另一种方法是选一个环外的进程作为牺牲品以释放该进程的资源。在使用这种方法时要特别小心，它可能正好持有环中某些进程所需的资源。最好是杀死可以从头开始运行而且不会带来副作用的进程。</li>
</ol>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>通过跟踪哪一个状态是安全状态，那一个状态是不安全状态，可以避免资源死锁。安全状态就是: 存在一个事件序列，保证所有的进程都能完成。不安全状态 (非等同于死锁) 就没有这样的保证。</p>
<p>可以使用<strong>银行家算法 (banker’s algorithm)</strong>来避免死锁的发生。该算法对每一个请求进行检查，检查如果满足这一请求后是否会到达<strong>安全状态</strong> (即如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每个进程运行完毕)。如是，那么就满足该请求。否则，就推迟这一请求的满足。为了检查状态是否安全，银行家需要考虑它是否有足够的资源满足某一个客户。如果可以，那么这笔代就是能够收回的，并且接着检查最接近最大限额的一个客户，以此类推。如果所有投资最终都能被收回，那么该状态是安全的，最初的请求可以被批准。本质上来说不可能实现，因为他需要获知未来的请求，而这些请求是不可知的</p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul>
<li><p><strong>破坏互斥条件</strong>: 一切都使用<strong>假脱机技术</strong> (指传输数据的过程中，将数据存放在临时工作区中，其它程序可以在之后的任意时间点对其访问，其运许若干个进程同时产生输出)。有可能无法达到预期效果。但有一个思想是经常可适用的，那就是避免分配那些不是绝对必须的资源，做到<strong>尽可能少的进程</strong>可以真正请求资源。</p>
</li>
<li><p><strong>破坏占有并等待条件</strong>: 思想是只要禁止已持有资源的进程<strong>再等待其他资源</strong>便可以消除死锁。一种方法是规定所有进程<strong>在开始执行前就请求所需的全部资源</strong>。如果资源都可用，就将他们分配给这个进程，于是该进程肯定能够运行结束。如果有一个或多个资源正被使用，那么就不进型分配，进程等待。这将会造成一个问题是很多进程直到运行时才知到它需要多少资源 (如果提前知道便可以使用银行家算法)。另一个问题是这种方法的资源利用率不是最优的。也有另一种方案，即要求当一个进程请求资源时，先站时释放其当前所占用的所有资源，然后再尝试一次获得所需的全部资源。</p>
</li>
<li><p><strong>破坏不可抢占条件</strong>: <strong>抢占资源</strong>并通过虚拟化的方式来避免抢占可能发生的混乱。</p>
</li>
<li><p><strong>破坏环路等待条件</strong>: 消除该条件有几种方法。一种是保证每个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，他必须先<strong>释放第一个资源</strong>。另一种是将所有<strong>资源统一编号</strong>。进程可以在任何时可提出资源请求，但是所有请求必须按照资源编号的顺序提出</p>
</li>
</ul>
<h2 id="死锁相关问题"><a href="#死锁相关问题" class="headerlink" title="死锁相关问题"></a>死锁相关问题</h2><h3 id="两阶段加锁-two-phase-locking"><a href="#两阶段加锁-two-phase-locking" class="headerlink" title="两阶段加锁 (two-phase locking)"></a>两阶段加锁 (two-phase locking)</h3><p>在很多数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁住的记录。当同时有多个进程运行时，就有出现死锁的危险。避免此情况的常用方法是<strong>两阶段加锁</strong>。在第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。某种意义上来说，这种方法类似于提前或者出现一些不可逆操作之前请求所有资源。</p>
<h3 id="通信死锁"><a href="#通信死锁" class="headerlink" title="通信死锁"></a>通信死锁</h3><p>该死锁通常发生在通信系统(比如网络)中。一种普遍的情形是，两个或两个以上进程利用发送信息来通信时，进程A向进程B发送请求消息，然后阻塞直至B回复。假设请求信息丢失，A将阻塞以等待回复，而B会阻塞等待一个向其发送命令的请求，因此发生死锁。与资源死锁不同的是，通信死锁是<strong>协同同步的异常</strong>，处于这种死锁中的进程如果是各自独立执行的，则无法完成服务。而资源死锁是<strong>竞争性同步的问题</strong>，进程在执行过程中如果与竞争的进程无交叉，便会顺利执行。为避免通信死锁，一般使用以下两种技术:</p>
<ol>
<li><strong>超时策略</strong>: 设定时间以确认信息丢失。</li>
<li><strong>协议</strong>: 避免超时策略设定时间太短引发重复发送信息。</li>
</ol>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>与死锁有些相似，那就是它也<strong>可以停止所有的转发进程</strong>。在某些情况下，进程意识到它不能获取下一个锁时，就会尝试礼貌地释放已经获得的锁，然后等待并再次尝试。如果有另一进程同时做出这个动作，二者便会不断地重复相同动作互相让路，形成活锁 (过程因为没有进程阻塞，因此不构成死锁)。由于活所包含了一些实际上并没有锁住的进程，因此可以通过先到先得的资源分配策略来避免<strong>饥饿</strong>。</p>
<blockquote>
<p><strong>饥饿 (starvation)</strong>: 在动态运行的系统中，在任何时刻都可能请求资源，这时就需要一些策略来决定谁获取什么资源，可能会导致一些进程永远得不到服务 (非死锁)，从而饥饿至死 (无限制地推后，尽管他没有被阻塞)。可以通过<strong>先到先得的资源分配策略</strong>来避免，等待最久的进程会是下一个被调度的进程，使最终都能够获得资源。</p>
</blockquote>

            </div>
        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li><br>
                All content copyright Tsung Han Tsai © 2018 • All rights reserved
            </ul>
        </div>
    </div>
</body>

 	
</html>
