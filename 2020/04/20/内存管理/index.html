<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/me.jpg">
	<link rel="shortcut icon" href="/img/me.jpg">
	
			    <title>
    Jack's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="java, computer science, programming">
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">JACK</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            	<a href="#s1">Category</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithms/">Algorithms</a></li><li><a class="category-link" href="/categories/IoTDB/">IoTDB</a></li><li><a class="category-link" href="/categories/LeetCode/">LeetCode</a></li><li><a class="category-link" href="/categories/Operating-System/">Operating System</a></li><li><a class="category-link" href="/categories/Other/">Other</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="Tag">
		                Tag
		            </a>
		        </li>
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
					<li class="translate-style">
						<a id="translateButtonObject" href="javascript:translatePage();">繁&#8644;简</a>
					</li>
                    
                    <li>
                        <a title="github" href="https://github.com/jack870131" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="linkedin" href="https://www.linkedin.com/in/tsung-han-jack-tsai-62696314b" target="_blank" rel="noopener">
                            <i class="icon fa fa-linkedin"></i>
                        </a>
                    </li>
                    
			</ul>
			<script type="text/javascript" src="/js/tw_cn.js"></script>
			<script type="text/javascript">
				var defaultEncoding = 2; //網站編寫字體是否繁體，1-繁體，2-簡體
				var translateDelay = 0; //延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0
				var cookieDomain = "https://jack870131.github.io/"; //Cookie地址, 一定要設定, 通常為你的網址
				var translateButtonId = "translateLink"; //默認互換id
				translateInitilization();
			</script>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://i.imgur.com/YFDq3rc.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>内存管理</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 4rem;">
                <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="操作系统与内存-RAM"><a href="#操作系统与内存-RAM" class="headerlink" title="操作系统与内存 (RAM)"></a>操作系统与内存 (RAM)</h2><p>操作系统的内存管理主要负责内存的分配与回收 (malloc 函数: 申请内存, free 函数: 释放内存)，地址转换也就是将逻辑地址转换成相应的物理地址等功能也是属于内存管理的范畴。</p>
<h2 id="CPU-寻址"><a href="#CPU-寻址" class="headerlink" title="CPU 寻址"></a>CPU 寻址</h2><p>现代 CPU 使用的是一种称为<strong>虚拟寻址 (virtual addressing)</strong>的寻址方式。使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实物理内存。实际上完成虚拟地址到物理地址的转换工作的硬件是 CPU 中的<strong>内存管理单元 (Memory Management Unit, MMU)</strong>。如下图所示:</p>
<img src="https://i.imgur.com/dFlC4sz.png" alt="MMU Principle" style="zoom:50%;">

<h2 id="地址空间-虚拟地址"><a href="#地址空间-虚拟地址" class="headerlink" title="地址空间 (虚拟地址)"></a>地址空间 (虚拟地址)</h2><p>如果把物理地址曝露给进程 (早期大型计算机并无物理内存的抽象) 会引发几个严重问题:</p>
<ol>
<li>如果用户程序可以寻址内存的每个字节，它们就可以很容易地破坏操作系统，使系统慢慢停止运行。</li>
<li>想要同时运行 (如果只有一个 CPU 就轮流运行) 多个程序是很困难的。</li>
</ol>
<p>要使多个应用程序同时处于内存中并且不互相影响，需要解决两个问题: <strong>保护</strong> and <strong>重定位</strong>。就像进程的概念创造了一类抽象的 CPU 以运行程序一样，<strong>地址空间</strong>为程序创造了一种抽象的内存，该空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间 (除了在一些特殊情况下进程需要共享它们的地址空间)。</p>
<h3 id="基指寄存器-amp-界限寄存器"><a href="#基指寄存器-amp-界限寄存器" class="headerlink" title="基指寄存器 &amp; 界限寄存器"></a>基指寄存器 &amp; 界限寄存器</h3><p>地址空间的问题是<strong>必须给每个程序一个自己独有的地址空</strong>间，使得一个程序中的地址24所对应的物理地址与另一个程序中的地址24所对应的物理地址不同。这个问题的解决办法是使用<strong>动态重定位</strong>，简单地把每个进程的地址空间映射到物理内存的不同部份。该方法是给每疙 CPU 配置<strong>基址寄存器</strong>和<strong>界限寄存器</strong>。当使用基址寄存器和界限寄存器时，程序装载到内存中连续的空闲位置且装载期间无需重定位。当一个进程运行时，程序的<strong>起始物理地址</strong>装载到基址寄存器中，程序的<strong>长度</strong>装载到界限寄存器中。举例如下:</p>
<blockquote>
<p>当第一个程序运行时，装载到这些硬件寄存器中的基址和界限值分别是0和16384。当第二个程序运行时，这些值分别是16384和32768。 如果第三个16KB 的程序被直接装载在第二个程序的地址之上并且运行，这时基址寄存器和界限寄存器里的值会是32768和16384。</p>
</blockquote>
<p>每次一个进程访问内存，取一条指令，读或写一个数据字，CPU 硬件会把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否大于等于界限寄存器里的值。如果访问的地址超过了界限，会产生错误并终止访问。</p>
<p>使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算。比较运算可以做得很快，但是加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。</p>
<h2 id="操作系统内存管理机制"><a href="#操作系统内存管理机制" class="headerlink" title="操作系统内存管理机制"></a>操作系统内存管理机制</h2><h3 id="分块-块式-存储管理"><a href="#分块-块式-存储管理" class="headerlink" title="分块 (块式) 存储管理"></a>分块 (块式) 存储管理</h3><p>远古时代的操作系统内存管理方式。将内存分为几个固定大小的块，每个块中止包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部份会被浪费。这些在块中未被利用的空间，称之为<strong>碎片</strong>。</p>
<h3 id="分页-页式-存储管理"><a href="#分页-页式-存储管理" class="headerlink" title="分页 (页式) 存储管理"></a>分页 (页式) 存储管理</h3><p>即把程序分成等长的<strong>页 (Page)</strong>，同样内存页被分成了和页面同样大小的<strong>页框 (page frame)</strong>。一个页可以装到一个页框里。在执行程序的时后我们根据一个页表去查找某个页面再内存的那个页框中，由此完成逻辑到物理的映射。相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。</p>
<p>在任何分页系统中都需要考虑两个主要问题以及提供解决方案:</p>
<ol>
<li><p>虚拟地址倒物理地址的映射必须非常快 (加速分页):</p>
<ul>
<li><strong>转换检测缓冲区</strong> (Translation Lookaside Buffer, TLB, 又称为<strong>快表</strong>): 为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的<strong>高速缓冲存储器 (Cache)</strong>, 其中的内容是页表的一部份或者全部内容。作为页表的 Cache, 它的作用与页表相似，但是提高了访问效率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次内存。有了快表，有时只要访问一次高速缓冲存储器和一次内存，这样可加速查找并提高指令执行速度。使用快表之后的地址转换流程如下:<ol>
<li>根据虚拟地址中的页号查快表。</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址。</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉块表中的一个页。</li>
</ol>
</li>
</ul>
</li>
<li><p>如果虚拟地址空间很大，页表也会很大 (处里大虚拟地址空间):</p>
<ul>
<li><strong>多级页表</strong>: 引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。</li>
<li><strong>倒排页表</strong>: 实际内存中的每个页框对应一个表象，而不是每个虚拟页面对应一个表象。表像记录了哪一个 &lt;进程, 虚拟页面&gt; 对则定位于该页框。虽然到排页表节省了大量空间，但它会使从虚拟地址到物理地址的转换变得困难。当进程n访问虚拟页面p时，硬件不再能通过把p当做只像页表的一个索引来查找物理页框。取而代之的是，它必须搜索整个倒排页表来查找某一个表项 &lt;n, p&gt;。此外，该搜索必须对每一个内存访问操作都要执行一次，而不仅仅是在发生缺页中断时执行。走出这种局面的办法是使用 TLB。如果 TLB 能够记录所有频繁使用页面，地址转换就可能变得像普通的页表一样快。但是，当发生 TLB 失效时，需要用软件搜索整个倒排页表 (建立一张散列表，用虚拟地址来散列)。</li>
</ul>
</li>
</ol>
<h3 id="分段-段式-存储管理"><a href="#分段-段式-存储管理" class="headerlink" title="分段 (段式) 存储管理"></a>分段 (段式) 存储管理</h3><p>存在一个程序中变量的数量远比其他部份的数量多时的情况，导致地址空间中分给符号表的块可能会被装满，但这时其他表中可能还有大量的空间，需要一种能令程序员不用管理表扩张和收缩的方法。页式管理虽然提高了内存利用率，但是页的概念并无任何实际意义。段式管理提供多个互相独立的称为段 (segment) 的地址空间，其占用的空间要比页小很多。段与页的最大不同是，<strong>段是有实际意义的</strong>，每个段定义了一组逻辑信息(e.g. 主程序段 MAIN, 子程序段 X, 数据段 D 和堆栈段 S)。分段管理通过段表对应逻辑地址 (e.g. 指针里面存储的数值就可以理解为内存里的一个地址，由操作系统决定) 与物理地址 (内存地址寄存器中的地址)，有助于在几个进程之间共享过程和数据。</p>
<h3 id="分段-v-s-分页"><a href="#分段-v-s-分页" class="headerlink" title="分段 v.s. 分页"></a>分段 v.s. 分页</h3><table>
<thead>
<tr>
<th align="center">考察点</th>
<th align="center">分页</th>
<th align="center">分段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">需要程序员了解正在使用这种技术吗</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">存在多少线性地址空间</td>
<td align="center">1</td>
<td align="center">许多</td>
</tr>
<tr>
<td align="center">整个地址空间可以超出物理存储器的大小吗</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">过程和数据可以被区分并分别被保护吗</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">其大小浮动的表可以很容易提供吗</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">用户间过程的共享方便吗</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">为什么发明这种技术</td>
<td align="center">为了得到大的线性地址空间而不必购买更大的物理存储器</td>
<td align="center">为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</td>
</tr>
</tbody></table>
<h3 id="分页分段结合-段页式-存储管理"><a href="#分页分段结合-段页式-存储管理" class="headerlink" title="分页分段结合(段页式)存储管理"></a>分页分段结合(段页式)存储管理</h3><p>该管理机制结合了段式管理和页式管理的优点，简单来说段页式管理机制就是把内存先分成若干段，每个段又分成若干页，页就是说段页式管理机制中，段与段之间以及段的内部都是离散的。</p>
<h2 id="内存超载"><a href="#内存超载" class="headerlink" title="内存超载"></a>内存超载</h2><p>有两种处里内存超载 (内存无法存下所有进程的情况) 的通用方法，分别是使用<strong>交换 (swapping) 技术</strong>或<strong>虚拟内存(virtual memory)</strong>。</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们醭运行时就不会占用内存 (其中一些进程会被周期性地唤醒以完成相关工作，然后又进入睡眠状态)。交换系统的操作如下所示:</p>
<p><img src="https://i.imgur.com/T9stsuW.png" alt="Swapping"></p>
<p>交换在内存中产生了多个空闲区 (hole, 也称为空洞)，通过把所有的进程尽可能地向下移动，有可能将这些小的空闲区合成一大块。该技术称为<strong>内存紧缩 (memory compaction)</strong>。通常不进型这个操作，因为会耗费大量 CPU 时间。</p>
<p>这里需要注意一个问题，即当<strong>进程被创建或换入时应该位它分配多大的内存</strong>。如果进程大小固定不变，则分配很简单，如果进程的空间可以增长，就会出现问题。为了减少因内存区域不够而引起的进程交换和移动所产生的开销，一种可用的方法是，当换入或移动进程时为它分配一些额外的内存 (为增长预留的空间)。然而，当进程被换出到磁盘时，应该只交换进程实际上使用的内存中的内，将额外的内存交换出去是一种浪费。</p>
<p>如果进程有两个可增长的段，例如: 作为堆使用以供变量动态分配和释放的数据段 and 存放普通局部变量与返回地址的堆栈段，则可以使用另一种安排，即在进程所占内存顶端的堆栈段向下增长，以及在底端的数据段向上增长。在这两者之间的内存可以供两个段使用。如果用完了，进程必须移动到足够大的空闲区中 (它可以被交换出内存直到内存中有足够空间)，或者结束该进程。</p>
<img src="https://i.imgur.com/cguBwEL.png" alt="Swapping (b)" style="zoom: 67%;">

<h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><p>在动态分配内存时，操作系统必须对其进行管理。一版友两种方法跟踪内存使用清况: <strong>位图</strong> and <strong>空闲区链表</strong>。</p>
<ul>
<li><strong>使用位图的存储管理</strong>: 使用位图方法时，内存可能被划分成数个字节的分配单元。每个分配单元对应于位图中的一位，0表示空闲，1表示占用 (或者相反)。分配单元越小，位图越大。因为内存的大小和分配单元的大小决定了位图的大小，所以它提供了一种简单的利用一块固定大小的内存区就能对内存使用情况进行记录的方法。这种方法的主要问题是，在决定把一个占k个分配单元的进程掉如内存时，存储管理器必须搜索位图，在位图中找出有k个连续0的串。这项操作是比较耗时的，也是位图的缺点。</li>
<li><strong>使用链表的存储管理</strong>: 即维护一个记录<strong>已分配内存段</strong>和<strong>空闲内存段</strong>的链表。其中链表中的一个节点包含一个进程或者是两个进程间的一块空闲区。当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以用来为创建的进程 (或从磁盘换入的进程)分配内存:<ul>
<li><strong>首次适配 (first fit)</strong>:存储管理器沿着锻炼表进行搜索，直到找到一个足够大的空闲区，除非空闲区大小和要分配的空间大小正好一样，否则将该空闲区分为两部份，一部份供进程使用，另一部份形成新的空闲区。这是一种速度很快的算法，因为它尽可能少地搜索链表节点。</li>
<li><strong>下次适配 (next fit)</strong>: 该算法的工作方式和首次适配算法相同，不同点是每次找到合适的空闲区时都记录当时的位置，以便在下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次适配算法那样每次都从头开始。其性能稍低于首次适配算法。</li>
<li><strong>最佳适配 (best fit)</strong>: 该算法搜索整个链表 (从开始到结束)，找出能够容纳进程的最小空闲区。其试图找出最接近实际需要的空闲区，已最好的匹配请求和可用空闲区，而不是先拆分一个以后可能会用到的大空闲区。该算法性能低于收次适配算法，而且比首次适配算法和下次适配算法浪配更多的内存 (surprised!)，因为它会产生大量无用的小空闲区。一般情况下，首次适配算法生成的空闲区更大一些。</li>
<li><strong>最差适配 (worst fit)</strong>: 为避免最佳适配诉法所产生的问题，可以考虑该算法。即总是分配最大的可用空闲区，使新的空闲区比较大从而可以继续使用，但这并非是个好办法。</li>
<li><strong>快速适配 (quick fit)</strong>: 该算法为那些常用大小的空闲区维护单独的链表。其性能是十分快速的，但它和所有将空闲区按大小排序的方案一样，都有一个共同的缺点，即在一个进程中只或被换出时，寻找它的相邻块并查看是否可以合并的过程是非常耗时的。如果不进行合并，内存将会很快分裂出大量进程无法利用的小空闲区。</li>
</ul>
</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>通过虚拟内存可以让程序拥有超过系统物理内存大小的可用内存空间。虚拟内存的基本思想是: <strong>每个程序拥有自己的地址空间</strong>，它让每个进程产生了一种自己在独享内存的错觉 (每个进程拥有一片连续完整的地址空间)。而实际上，它通常是被分隔成多个物理内存碎片，还有部份占时存储在外部磁盘上，在需要时进行交换。</p>
<p><strong>局部性原理</strong>是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部份程序到内存就开始运行。</p>
<blockquote>
<p>局部性原理: 在某个较短的时间段内，程序执行局限于某一小部份，程序访问的存储空间也局限于某区域。局部性原理表现在以下两方面:</p>
<ol>
<li><strong>时间局部性</strong>: 如果程序中的某条指令一旦执行，不久以后该指令可能再次执行; 如果某数据被访问过，不久后该数据可能再次被访问产生时间局部性的典型原因，是由于再程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong>: 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
</blockquote>
<p>时间局部性是通过<strong>将近来使用的指令和数据保存到高速缓存存储器中</strong>，并使用高速缓存的层次结构实现。空间局部性通常是<strong>使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现</strong>。虚拟内存技术实际上就是建立了 <strong>“内存 – 外存”</strong> 的两级存储器结构，利用局部性原理实现高速缓存。</p>
<p><strong>虚拟内存的实现</strong>需要建立在离散分配的内存管理方式的基础上。主要有以下三种方式:</p>
<ol>
<li><strong>请求分页存储管理</strong> (在基本分页系统基础上，增加了请求调页功能和页面置换功能以支持虚拟内存，较为常用)</li>
<li><strong>请求分段存储管理</strong></li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p>不管是哪种实现方式，都需要:</p>
<ol>
<li><strong>一定容量的内存和外存</strong>: 在载入程序的时候，只需要将程序的一部份装入内存，而其它部份留在外存，然后程序即可执行。</li>
<li><strong>缺页中断</strong>: 如果需执行的指令或访问的数据<strong>尚未在内存中</strong> (称为缺页或缺段)，则由处里器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序。</li>
<li><strong>虚拟地址空间</strong>: 逻辑地址到物理地址的转换。</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>当发生缺页中断时，操作系统必须存中选择一个页面将其换出内存以腾出空间。</p>
<blockquote>
<p><strong>缺页中断</strong>就是要访问的<strong>页</strong>不在内存中，需要操作系统将其调入内存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>用来选择淘汰哪页的规则叫做<strong>页面置换算法</strong>，可以视作淘汰页面的规则。</p>
<h3 id="常见页面置换算法"><a href="#常见页面置换算法" class="headerlink" title="常见页面置换算法"></a>常见页面置换算法</h3><ul>
<li><p><strong>OPT (最佳页面置换)</strong>: 理想情况，不可能实现，一般作为衡量其它置换算法的方法。</p>
</li>
<li><p><strong>FIFO (先进先出)</strong>: 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰，可能造成抛弃重要页面的问题。</p>
</li>
<li><p><strong>LRU (Least Recent Used, 最近最少使用)</strong>: 该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当需要淘汰一个页面时，选择现有页面中T值最大的，即最近且最久未使用的页面予以淘汰。</p>
</li>
<li><p><strong>LFU (Least Frequently Used, 最少使用页面排序)</strong>: 该算法会让系统维护一个<strong>按最近一次访问时间排序</strong>的页面链表，链表首节点是最近刚刚使用过的页面，尾节点是最久未使用的页面。访问内存时，找到相应页面，并把它移到链表之手。缺页时，置换链表尾节点的页面。也就是内存中使用越频繁的页面，被保留的时间也相对较长。</p>
</li>
</ul>

            </div>
        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li><br>
                All content copyright Tsung Han Tsai © 2018 • All rights reserved
            </ul>
        </div>
    </div>
</body>

 	
</html>
