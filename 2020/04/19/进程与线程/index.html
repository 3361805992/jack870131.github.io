<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/me.jpg">
	<link rel="shortcut icon" href="/img/me.jpg">
	
			    <title>
    Jack's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="java, computer science, programming">
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">JACK</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            	<a href="#s1">Category</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithms/">Algorithms</a></li><li><a class="category-link" href="/categories/IoTDB/">IoTDB</a></li><li><a class="category-link" href="/categories/LeetCode/">LeetCode</a></li><li><a class="category-link" href="/categories/Operating-System/">Operating System</a></li><li><a class="category-link" href="/categories/Other/">Other</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="Tag">
		                Tag
		            </a>
		        </li>
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
					<li class="translate-style">
						<a id="translateButtonObject" href="javascript:translatePage();">繁&#8644;简</a>
					</li>
                    
                    <li>
                        <a title="github" href="https://github.com/jack870131" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="linkedin" href="https://www.linkedin.com/in/tsung-han-jack-tsai-62696314b" target="_blank" rel="noopener">
                            <i class="icon fa fa-linkedin"></i>
                        </a>
                    </li>
                    
			</ul>
			<script type="text/javascript" src="/js/tw_cn.js"></script>
			<script type="text/javascript">
				var defaultEncoding = 2; //網站編寫字體是否繁體，1-繁體，2-簡體
				var translateDelay = 0; //延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0
				var cookieDomain = "https://jack870131.github.io/"; //Cookie地址, 一定要設定, 通常為你的網址
				var translateButtonId = "translateLink"; //默認互換id
				translateInitilization();
			</script>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://i.imgur.com/YFDq3rc.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>进程与线程</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中最核心的概念是进程，是对正在运行程序的一个抽象。一个进程就是一个正在被执行程序的实例，包括程序计数器、寄存器和变量的当前值。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别:</p>
<ul>
<li><strong>用户态 (user mode)</strong>: 用户态运行的进程可以直接读取用户程序的数据。</li>
<li><strong>系统态 (kernel mode)</strong>: 系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ul>
<h3 id="进程-v-s-程序"><a href="#进程-v-s-程序" class="headerlink" title="进程 v.s. 程序"></a>进程 v.s. 程序</h3><p>如果将操作系统内部视为一个厨房，则程序 (适当形式描述的算法) 相当于食谱，输入的数据相当于食材，CPU 处理器等同于厨师。进程则是指某种类型的活动，比如厨师阅读食谱，取食材以及烘焙等动作的总和。</p>
<h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>若干进程可以共享单个 CPU，单个 CPU 一次只能运行一个进程。处里器在各个进程之间来回快速切换，在任何一个给定的瞬间仅有一个进程真正在运行。由于 CPU 在各个进程之间来回快速切换，所以每个进程执行及运算的速度是不确定的，当同一进程再次运行时，其运算速度通常不可再现。进程切换的基本顺序如下:</p>
<ol>
<li>保存当前进程状态</li>
<li>切换到高优先级进程 (每个进程包含各自程序)</li>
<li>切换到原本进程 (从原本进度开始执行)</li>
</ol>
<h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>当进程创建了另一进程后，父进程和子进程就以某种形式继续保持关联。进程只可以有一个父进程，但是可以有零个、一个、两个或多个子进程。举例 UNIX 在启动时如何初始化自己来说明进程层次的作用:</p>
<blockquote>
<p>一个称为 init 的特殊进程出现在启动映像中。当他开始运行时，读入一个说明终端数量的文件。接这，未每个终端创建一个新进程。这些进绳等待用户登录。如果有一个用户登录成功，该登陆进程就执行一个 shell 准备接收命令。所接收的这些命令会启动更多的进程，以此累堆，在整个系统中，所以的进程都属于以 init 为根的一棵树。</p>
</blockquote>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p><img src="https://i.imgur.com/hUQ5x3Z.jpg" alt="Process State"></p>
<ul>
<li><p><strong>创建态 (new)</strong>: 进程正在被创建，未达到就绪态。四种事件会导致进程创建:</p>
<ol>
<li><p>系统初始化</p>
</li>
<li><p>正在运行的程序执行创建进程的系统调用</p>
</li>
<li><p>用户请求创建一个新进程</p>
</li>
<li><p>一个批处理作业的初始化</p>
</li>
</ol>
</li>
<li><p><strong>就绪态 (ready)</strong>: 可运行，但因位其他进程正在运行而战时终止，一旦得到处里器资源 (处里器的时间片) 即可运行。</p>
</li>
<li><p><strong>运行态 (running)</strong>: 进程实际占用 CPU (单核 CPU 任意时刻只有一个进程处于该状态)。</p>
</li>
<li><p><strong>阻塞态 (waiting)</strong>: 又称为等待状态，除非某外部事件 (资源可用或 IO 操作完成) 发生，否则即使处里器空闲，进程也不能运行。</p>
</li>
<li><p><strong>结束态 (terminated)</strong>: 进程正在从系统上消失，可能是进程正常结束或其他原因造成中断。四种事件会导致进程终止:</p>
<ol>
<li>正常退出(自愿)</li>
<li>出错退出(自愿)</li>
<li>严重错误(非自愿)</li>
<li>被其他进程杀死(非自愿)</li>
</ol>
</li>
</ul>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>为实现进程模型，操作系统维护着一张表格 (数组 or 链表结构)，即<strong>进程表 (process table)</strong>。每个进程占用一个进程表项。该表象包含了进程状态的重要信息，包括寄存器、程序计数器、堆栈指针和优先级等以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证甘进程随后能再次启动，就像从未被中断过一样。</p>
<p>了解进程表后，就可以对在 CPU 上如何维持多个顺序进程的错觉进行更多的阐述。与每一 I/O 泪关联的是一个称作<strong>中断向量 (interrupt vector)</strong>的位置。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，某用户进程正在运行，则中断硬件将程序计数器、程序状态字和寄存器等压入堆栈，计算机随即跳转到中段向量所指示的地址。</p>
<p>以下为中断发生后操作系统最底层的工作顺序:</p>
<ol>
<li><p>硬件压入堆栈程序计数器等</p>
</li>
<li><p>硬件从中断向量装入新的程序技术器</p>
</li>
<li><p>汇编语言过程保存寄存器值</p>
</li>
<li><p>汇编语言过程设置新的堆栈</p>
</li>
<li><p>C中断服务例程运行</p>
</li>
<li><p>调度程序决定下一个将运行的进程</p>
</li>
<li><p>C过程返回至汇编代码</p>
</li>
<li><p>汇编语言过程开始运行新的当前进程</p>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>需要线程的主要原因:</p>
<ol>
<li>在许多应用中同时发生着多种活动。其种某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行的多个线程，程序设计会更加简单。</li>
<li>由于线程比进程更轻量级，所以他们比进程更快更容易创建，也更容易撤销。</li>
<li>性能问题。多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在这大量的计算和大量的 I/O 处里，拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序执行的速度。</li>
</ol>
<h3 id="进程-v-s-线程"><a href="#进程-v-s-线程" class="headerlink" title="进程 v.s. 线程"></a>进程 v.s. 线程</h3><p>线程是进程划分成更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程有可能会互相影响 (没有保护)，多个线程可以共享公共内存，对彼此进行读写。进程执行开销大，但利于资源的管理与保护，线程则相反。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程给进程模型中增加了一项内容，即在同一进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一进程中并行运行多个线程 (多个线程共享同一各地址空间和资源)，是对在同一计算机上并行运行多个进程 (多个进程共享物理内存、磁盘等资源)的模拟。多线程是用来描述在同一各进程中允许多个线程的情形 (允许线程切换在纳秒级完成)。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://i.imgur.com/iVmZzxs.png" alt="Thread State"></p>
<ul>
<li><strong>创建 (New)</strong>: 创建线程</li>
<li><strong>就绪 (Ready)</strong>: 可以被调度执行</li>
<li><strong>运行 (Running)</strong>: 拥有 CPU 并且是活跃的</li>
<li><strong>阻塞 (Blocking)</strong>: 等待某个释放它的事件</li>
<li><strong>终止 (Dead)</strong>: 不可被调度执行</li>
</ul>
<h2 id="进程间通信-Inter-Process-Communication-IPC"><a href="#进程间通信-Inter-Process-Communication-IPC" class="headerlink" title="进程间通信 (Inter Process Communication, IPC)"></a>进程间通信 (Inter Process Communication, IPC)</h2><p>进程间通信主要需要解决三个问题:</p>
<ol>
<li>一个进程如何把信息传递给另一个</li>
<li>确保两个或更多的进程在关键活动中不会出现交叉</li>
<li>保证线程的正确顺序</li>
</ol>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的时序，称为<strong>竞争条件 (race condition)</strong>。比如一机器有许多槽位并且进程 A 与进程 B 开始如下操作:</p>
<ol>
<li>进程 A 先运行，发现槽位3为空并且进行标记，此时发生时钟中断， CPU 认为 A 已经运行足够长时间，决定切换到进程 B 运行。</li>
<li>进程 B 运行，同样发现槽位3为空并且进行标记。</li>
<li>进程 B 继续运行，将文件存储到槽位3。</li>
<li>进程 A 接着从上次中断的地方开始运行，同样将文件存储到槽位3，覆盖掉 B 的文件。</li>
<li>此结果将会造成 B 永远得不到结果。</li>
</ol>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对共享内存进行访问的程序片段称为<strong>临界区域 (critical region)</strong> 或<strong>临界区 (critical section)</strong> 。要避免竞争条件，需要满足以下四个条件:</p>
<ol>
<li>任何两个进程不能同时处于其临界区</li>
<li>不对 CPU 的速度和数量作任何假设</li>
<li>临界区外运行的进程不得阻塞其他进程</li>
<li>不得使进程无限期等待进入临界区</li>
</ol>
<h3 id="忙等待的互斥"><a href="#忙等待的互斥" class="headerlink" title="忙等待的互斥"></a>忙等待的互斥</h3><p>要避免造成上述错误，要找出某种途径来阻止多个进程同时写共享数据，即确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作 or 不会进入临界区，该动作称为<strong>互斥 (mutual exclusion)</strong>。要实现互斥有以下几种方案:</p>
<ol>
<li><p><strong>屏蔽中断</strong>: 每个进程在进入临界区后立即屏蔽所有中断，并在要离开之前再打开中断。屏蔽中断后，时钟中断也会被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换，代表在屏蔽中断之后 CPU 将不会被切换到其他进程。这样一但某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不必担心其他进程介入。屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程不是一种合适的互斥机制。</p>
</li>
<li><p><strong>锁变量</strong>: 设0表示临界区内没有进程，1表示已经有某个进程进入临界区。一个共享 (锁) 变量，其初始值为0，当一个进程想进入其临界区时，它首先测试这把锁，如果锁值为0，则该进程将其设置为1并进入临界区。若这把锁的值已经为1，则该进程将等待直到其值变为0。</p>
</li>
<li><p><strong>严格轮换法</strong>: 该方案要求两个进程严格地轮流进入临界区，任何一各进程都不可能在一轮中执行两次。设整型变量 turn 初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程0检查 turn, 发现值为0，于是进入临界区。进程1也发现其值为0，所以在一个等待循环中不停地测试 turn, 看其值何时变为1。</p>
</li>
</ol>
<blockquote>
<p>连续测试一个变量到某个值出现为止，称为<strong>忙等待 (busy waiting)</strong>。由于这种方式浪费 CPU 时间，所以通常应该避免。只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁称为<strong>自旋锁 (spin lock)</strong>，也是互斥锁的一种表现形式</p>
</blockquote>
<p>   尽管该算法避免了所有的竞争条件，但由于违反了条件3 – 临界区外运行的进程不得阻塞其他进程，所以不能作为一个很好的备选方案。</p>
<ol start="4">
<li><p><strong>Peterson 解法</strong>: 在使用共享变量 (即进入临界区) 之前，各疙进程使用其进程号0或1作为参数来调用 enter_region。该调用在需要时将使进程等待。直到能安全地进入临界区。在完成对共享变量的操作之后，进城将调用 leave_region，表示操作以完成，若其他的进程希望进入临界区，现在就可以进入。</p>
</li>
<li><p><strong>TSL 指令</strong>: 该方案需要硬件支持。某些计算机中，特别是那些设计为多处里器的计算机，都有一条指令: TSL RX, LOCK，称为测试并加锁 (test and set lock)，它将一个内存字 lock 读到寄存器 RX 中，然后再该内存地址上存一个非零值。读字和写字操作保证是不可分割的，即该指令结束之前其他处里器均不允许访问该内存字。执行 TSL 指令的 CPU 将锁住内存总线，以禁止其他 CPU 在本指令结束之前访问内存。与屏蔽中断不同的是，屏蔽中断无法阻止处里器2在处里器1的读操作与写操作之间访问内存字，锁住存储总线则可以。</p>
</li>
</ol>
<h3 id="睡眠-sleep-与唤醒-wakeup"><a href="#睡眠-sleep-与唤醒-wakeup" class="headerlink" title="睡眠 (sleep) 与唤醒 (wakeup)"></a>睡眠 (sleep) 与唤醒 (wakeup)</h3><p>Peterson 解法与 TSL 解法都是正确的，但他们都有<strong>忙等待</strong>的缺点，他们本质上是这样的，当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。这种方法不仅浪费 CPU 时间，而且还可能引起<strong>优先级反转问题 (priority inversion problem)</strong>。</p>
<blockquote>
<p>优先级反转问题 (priority inversion problem): 考虑一台计算机有两个进程，A进程优先级较高，B较低。调度规则规定，只要A处于就绪态它就可以运行。在某一时刻，B处于临界区中，此时A变到就绪态，准备运行。现在A开始忙等待，但由于当A就序时B不会被调度，也就无法离开临界区，所以A将永远忙等待下去。</p>
</blockquote>
<p>接下来则引入 <strong>sleep</strong> 和 <strong>wakeup</strong>，他们在进程无法进入临界区时将其阻塞，而非忙等待。 </p>
<p><strong>生产者 - 消费者 (producer-consumer) 问题</strong><br>两个进程共享一个公共的固定大小的缓冲区，其中一个是生产者，将信息放入缓冲区，另一个是消费者，从缓冲区中取出信息。当缓冲区已满，而此时生产者还想向其中放入一个新的数据项的情况。其解决办法是让生产者睡眠 (sleep)，待消费者从缓冲区中取出一个或多个数据项时再唤醒它，反之亦然。</p>
<h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量 (semaphore)"></a>信号量 (semaphore)</h3><p>信号量是一个计数器，有相较于互斥量更多的取值空间。不单单可以实现线程间的互斥，更可以用于较为复杂的<strong>进程同步 (synchronization，亦可称为同步锁的一种)</strong>。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</p>
<h3 id="互斥量-or-互斥锁-mutex"><a href="#互斥量-or-互斥锁-mutex" class="headerlink" title="互斥量 or 互斥锁 (mutex)"></a>互斥量 or 互斥锁 (mutex)</h3><p>信号量的简化版本，可以说是信号量再仅取值 0/1 时的特例，仅适用于管理共享资源或一小段代码。互斥量是一个可以处于两态之一的变量: 解锁或加锁 (<strong>二元锁</strong>机制)。当一个线程 (或进程) 需要访问临界区时，调用 mutex_lock。如果该互斥量当前是解锁的 (即临界区可用)，此调用成功，调用线程可以自由进入该临界区。如果该互斥量已经加锁，调用线程将被阻塞，直到再临界区中的线程完成并调用 mutex_unlock。如果多个线程被阻塞再该互斥量上，将随机选择一个线程并允许它获得锁。采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>对调度的定义如下:</p>
<blockquote>
<p>当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争 CPU。指要有两个或更多的进程处于就绪状态，这种情形就会发生。如果只有一个 CPU 可用，那么就必须选择下一个要运行的进程。再操作系统中，完成选择工作的这一部份称为<strong>调度程序 (scheduler)</strong>，该程序使用的算法称为<strong>调度算法 (scheduling algorithm)</strong>。</p>
</blockquote>
<p>尽管有些不同，但许多适用于进程调度的处里方法同样也是用于线程调度。</p>
<h3 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h3><p>需要调度处里的各种情形:</p>
<ol>
<li><p>在创建一个新进程之后，需要决定是运行父进程还是子进程</p>
</li>
<li><p>在一个进程退出时必须做出调度决策</p>
</li>
<li><p>当一个进程阻塞在 I/O 和信号量上或由于其它原因阻塞时，必须选择另一个进程运行</p>
</li>
<li><p>在一个 I/O 中断发生时，必须做出调度决策</p>
</li>
</ol>
<p>如果硬件时中提供周期性中断，可以在每个或 n 个时钟中断时做出调度决策。根据如何处里时钟中断，可以把调度算法分为两大类:</p>
<ul>
<li><p><strong>非抢占式</strong>: 挑选一个进程，然后让进程运行直至被阻塞或释放 CPU。即使该进程运行很久，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度。在处里完时钟中断后，如果没有更高优先级的进程等待，则被中断的进程会继续执行。</p>
</li>
<li><p><strong>抢占式</strong>: 挑选一个进程，并且让该进程运行某个固定时段的最大值，如果该时段结束时，该进程仍在运行，他就被挂起，而调度程序挑选另一个进程运行</p>
</li>
</ul>
<h3 id="常见进程调度算法"><a href="#常见进程调度算法" class="headerlink" title="常见进程调度算法"></a>常见进程调度算法</h3><ul>
<li><strong>先到先服务 (First Come First Served, FCFS)</strong>: 从就绪队列中选择一个最先进入该队列的进程为其分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞，放弃占用 CPU 时再重新调度。</li>
<li><strong>最短作业优先 (Shortest Job First, SJF)</strong>: 从就绪队列中选出一个估计运行时间最短的进程为其分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞，放弃占用 CPU 时再重新调度。</li>
<li><strong>最短剩余时间优先 (Shortest Remaining Time First, SRTS)</strong>: 调度程序总是选择剩余运行时间最短的那个进程运行。</li>
<li><strong>时间片轮转调度 (Round-Robin, RR)</strong>: 最古老，最简单，最公平且使用最广的算法，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>优先级调度 (Priority Based Scheduling)</strong>: 为每个流程分配优先级，首先执行具有最高优先级的进程。具有相同优先级的进程以 FCFS 的方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
<li><strong>多级反馈队列调度算法 (Multi-level Feedback Queue, MFQ)</strong>: 该算法既能使高优先级的作业得到响应又能使短作业 (进程) 迅速完成，因而他是目前被<strong>公认的一种较好的进程调度算法，UNIX 便是采用这种算法</strong>。</li>
<li><strong>最短进程优先 (Shortest Process First, SPF)</strong>: 优先运行最短的作业以达到响应时间最短，该算法虽然照顾了短进程却忽略了长进程。</li>
<li><strong>彩票调度 (Lottery Scheduling)</strong>: 向进程提供各种系统资源 (如 CPU 时间) 的彩票 (可以给重要的进程额外的彩票)。一旦需要做出一项调度决策时，就随机收出一张彩票，拥有该彩票的进程获得该资源。</li>
<li><strong>公平共享调度 (Completely Fair Scheduling)</strong>: 在调度处里之前考虑谁拥有该进程。在这种模式下，每个进程分配到 CPU 时间的一部份，而调度程序以一种强制的方式选择进程。如果两个用户都得到 50% 的 CPU 时间保证，那么无论一个用户有多少进程存在，每个用户都会得到应有的 CPU 份额。</li>
</ul>

            </div>
        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li><br>
                All content copyright Tsung Han Tsai © 2018 • All rights reserved
            </ul>
        </div>
    </div>
</body>

 	
</html>
